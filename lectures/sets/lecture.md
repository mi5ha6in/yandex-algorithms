# Множества

[Лекция](https://www.youtube.com/watch?v=PUpmV2ieIHA&list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5&index=4)

Множество – структура данных, которая является реализацией математического
объекта множество. Позволяет хранить ограниченное число значений без
определенного порядка. Обязательны три операции:

1. Добавлять элемент
1. Проверять наличие элемента
1. Удалять элемент

## Пример

Большое множество натуральных чисел.

- Придумаем функцию, которая сопоставляет каждому элементу какое-либо небольшое
число
- Вычислим функцию от элемента
- Положим элемент в список с номером, равным значению функции

Такая функция называется
[хеш-функцией](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)

[Принцип
Дирихле](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%94%D0%B8%D1%80%D0%B8%D1%85%D0%BB%D0%B5_(%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%B8%D0%BA%D0%B0))

Возникает проблема, что несколько чисел могут быть сопоставлены с одинаковым
числом, являющимся результатом хеш-функции. [Коллизия
хеш-функции](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BB%D0%BB%D0%B8%D0%B7%D0%B8%D1%8F_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8).

Пример хеш-функции для числа – последняя цифра числа F(X) = X % 10 Для числа 137
=> 7, 145 => 5, 17 => 7

Добавим число 27. F(27) = 27 % 10 = 7

``` text
                                            ↓
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                                          [ 27]
```

Добавим число 3. F(3) = 3 % 10 = 3

``` text
                    ↓
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                   [ 27]
```

Добавим число 17. F(17) = 17 % 10 = 7

``` text
                                            ↓
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                   [ 27]
                                          [ 17]
```

Если множество размером N и в нем лежит K элементов, то можно перебрать все
элементы за O(N + K)

Идем по всем спискам, если список пуст, переходим к следующему. Если список не
пуст, то идем по вложенным элементам, после этого продолжаем идти по спискам

``` text
  ↓     ↓     ↓     ↓     ↓     ↓     ↓     ↓     ↓     ↓
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                 →[ 3 ]                  →[ 27]
                                         →[ 17]
```

Если в процессе обхода печатать содержимое, то вывод будет: 3, 27, 17. В
множествах не нужно опираться на порядок. В данном случае порядок идет по
увеличению значения хеш-функции, в тех местах, где значения совпали – в порядке
добавления.

1. Проверяем элемент в множестве Проверим есть ли число 21. F(21) = 21 % 10 = 1
Ищем в списке с индексом 1. Он пуст, => числа 21 в нем нет.

``` text
        ↓                                   
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                   [ 27]
                                          [ 17]
```

Проверим есть ли число 13. F(13) = 13 % 10 = 3 Ищем в списке с индексом 3. Числа
13 в нем нет.

``` text
                    ↓                      
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                   [ 27]
                                          [ 17]
```

Проверим есть ли число 17. F(13) = 17 % 10 = 7 Ищем в списке с индексом 7. Число
17 в нем есть.

``` text
                    ↓                      
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                   [ 27]
                                          [ 17]
```

2. Добавим число 87. F(87) = 87 % 10 = 7

``` text
                                            ↓
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                   [ 27]
                                          [ 17]
                                          [ 87]
```

3. Удалим число 27. Чтобы удалить, нужно с начало найти F(27) = 27 % 10 = 7

``` text
                                            ↓
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                  →[ 27]
                                          [ 17]
                                          [ 87]
```

Если просто удалить число 27, нужно будет сдвигать числа 17 и 87. Поэтому можно
удаляемому элементу присвоить значение последнего элемента, а затем удалить
последний элемент. Таким образом экономим количество операций присваивания.
Повторимся, сохранять взаимный порядок в хэш-таблице не нужно. В такой структуре
данных не надо рассчитывать на порядок.

``` text
                                            ↓
[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]
                  [ 3 ]                  →[ 87]
                                          [ 17]
```

Удаление элемента после нахождения происходит за O(1), но поиск занял в среднем
O(K/N) K/N - это высота "столбцов" при равномерном заполнении. Например, если
элементов 20, длинна списка 10, то "столбцы" будут высотой 2. И поиск элемента
будет за O(20/10) == O(2)

Термины F(X) = X % setsize – хеш-функция  
myset(список списков) – хеш-таблица  
Совпадение значений хеш-функции для разных параметров – коллизия
